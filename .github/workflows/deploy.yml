name: Deploy SupabaseLocal

on:
  push:
    branches: [main, master]
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Local Server
    runs-on: self-hosted
    environment: Supabase
    steps:
      - name: Stop Existing Services
        run: |
          # Only try to stop if the file exists from a previous successful checkout
          if [ -f "docker-compose.yml" ]; then
            docker compose down --remove-orphans || true
          fi
          
          # 2. Use Docker to clean up application files EXCEPT the volumes directory.
          # We NEVER wipe /volumes because that is where the persistent user data lives.
          docker run --rm -v $PWD:/work alpine sh -c "find /work -mindepth 1 -maxdepth 1 ! -name 'volumes' -exec rm -rf {} +" || true

      - name: Environment Diagnostics
        run: |
          echo "Workspace: ${{ github.workspace }}"
          echo "PWD: $PWD"
          ls -la
          
      - name: Fix Permissions for Checkout
        run: |
          # If volumes exists, make sure it's accessible so checkout doesn't fail
          if [ -d "volumes" ]; then
            docker run --rm -v ${{ github.workspace }}:/work alpine sh -c "chmod -R 777 /work/volumes || true"
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Use default checkout which includes cleaning, 
          # we fixed permissions above to allow this.
          clean: true 

      - name: Create .env file
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          ANON_KEY: ${{ secrets.ANON_KEY }}
          SERVICE_ROLE_KEY: ${{ secrets.SERVICE_ROLE_KEY }}
          DASHBOARD_USERNAME: ${{ secrets.DASHBOARD_USERNAME }}
          DASHBOARD_PASSWORD: ${{ secrets.DASHBOARD_PASSWORD }}
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          if [ -z "$POSTGRES_PASSWORD" ]; then echo "❌ POSTGRES_PASSWORD secret is empty!" && exit 1; fi
          
          cat <<EOF > .env
          # Secrets (Injected from GitHub)
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=$POSTGRES_PASSWORD
          JWT_SECRET=$JWT_SECRET
          ANON_KEY=$ANON_KEY
          SERVICE_ROLE_KEY=$SERVICE_ROLE_KEY
          DASHBOARD_USERNAME=$DASHBOARD_USERNAME
          DASHBOARD_PASSWORD=$DASHBOARD_PASSWORD
          PG_META_CRYPTO_KEY=REPLACE_ME_PG_META_CRYPTO_KEY_32_CHARS
          
          # Database
          POSTGRES_HOST=db
          POSTGRES_DB=postgres
          POSTGRES_PORT=5432
          
          # API Gateway
          KONG_HTTP_PORT=8100
          KONG_HTTPS_PORT=8143
          
          # Auth & API URLs
          SERVER_IP=$SERVER_IP
          SUPABASE_PUBLIC_URL=http://$SERVER_IP:8100
          API_EXTERNAL_URL=http://$SERVER_IP:8100
          SITE_URL=http://$SERVER_IP:7001
          ADDITIONAL_REDIRECT_URLS=http://$SERVER_IP:7001,http://localhost:5173,http://localhost:3000
          
          # Configuration
          JWT_EXPIRY=3600
          DISABLE_SIGNUP=false
          ENABLE_EMAIL_SIGNUP=true
          ENABLE_ANONYMOUS_USERS=false
          ENABLE_EMAIL_AUTOCONFIRM=true
          
          # Email Settings
          SMTP_ADMIN_EMAIL=admin@example.com
          SMTP_HOST=supabase-mail
          SMTP_PORT=2500
          SMTP_USER=fake_mail_user
          SMTP_PASS=fake_mail_password
          SMTP_SENDER_NAME=TriathlonHelper
          MAILER_URLPATHS_CONFIRMATION="/auth/v1/verify"
          MAILER_URLPATHS_INVITE="/auth/v1/verify"
          MAILER_URLPATHS_RECOVERY="/auth/v1/verify"
          MAILER_URLPATHS_EMAIL_CHANGE="/auth/v1/verify"
          
          # PostgREST
          PGRST_DB_SCHEMAS=public,storage,graphql_public
          
          # Phone Auth
          ENABLE_PHONE_SIGNUP=false
          ENABLE_PHONE_AUTOCONFIRM=false
          
          # Studio
          STUDIO_DEFAULT_ORGANIZATION=Triathlon
          STUDIO_DEFAULT_PROJECT=TriathlonHelper
          IMGPROXY_ENABLE_WEBP_DETECTION=true
          EOF

      - name: Prepare Config and Permissions
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: |
          mkdir -p volumes/db/data
          mkdir -p volumes/storage
          mkdir -p volumes/api
          mkdir -p volumes/logs
          
          echo "Injecting passwords into roles.sql..."
          # Use | as delimiter to handle passwords with / or #
          sed "s|REPLACE_ME_PASSWORD|$POSTGRES_PASSWORD|g" volumes/db/roles.sql > volumes/db/roles.sql.tmp && mv volumes/db/roles.sql.tmp volumes/db/roles.sql
          
          echo "Checking for essential SQL scripts..."
          ls -l migrations/00-supabase-core.sql migrations/01-base-tables.sql volumes/db/roles.sql
          
          # Use docker to fix permissions
          docker run --rm -v $PWD/volumes:/target alpine sh -c "chmod -R 777 /target && chown -R 999:999 /target/db"

      - name: Deploy with Docker Compose
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: |
          docker compose up -d --remove-orphans
          
      - name: Apply Migrations
        run: |
          echo "Waiting for database to be ready..."
          max_attempts=60
          attempt=0
          # We wait until psql can actually log in and execute a query
          # This ensures the 'postgres' role and the server are fully initialized
          until docker exec supabase-db psql -U postgres -d postgres -c "SELECT 1" > /dev/null 2>&1 || [ $attempt -eq $max_attempts ]; do
            echo "Waiting for DB to be fully ready... (Attempt $attempt/$max_attempts)"
            sleep 3
            attempt=$((attempt+1))
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "❌ Database failed to become ready in time."
            docker logs supabase-db --tail 100
            exit 1
          fi
          
          echo "Applying migrations..."
          # Sort migrations numerically/chronologically (natural sort)
          files=$(ls migrations/*.sql | sort -V)
          for f in $files; do
            echo "Running $f..."
            docker exec -i supabase-db psql -U postgres -d postgres < "$f" || { echo "❌ Failed on $f"; exit 1; }
          done
          echo "✅ All migrations applied successfully."
          
      - name: Show Logs on Failure
        if: failure()
        run: |
          echo "=== Workspace Contents ==="
          ls -la
          echo "=== DB Logs ==="
          docker compose logs db --tail 100 || true
          echo "=== All Services Status ==="
          docker compose ps
