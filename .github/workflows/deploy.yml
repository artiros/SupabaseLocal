name: Deploy SupabaseLocal (Self-Hosted)

on:
  push:
    branches: [main, master]
  workflow_dispatch:

jobs:
  deploy:
    name: Local Server Deployment
    runs-on: self-hosted
    environment: Supabase
    steps:
      - name: Stop Existing Services and Cleanup
        run: |
          # Stop everything first to release file locks
          docker compose down || true
          # Use Docker's root privileges to unlock the workspace for the runner
          # We make EVERYTHING writable so the 'actions/checkout' cleanup can work
          docker run --rm -v ${{ github.workspace }}:/work alpine sh -c "chmod -R 777 /work || true"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create .env file
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          ANON_KEY: ${{ secrets.ANON_KEY }}
          SERVICE_ROLE_KEY: ${{ secrets.SERVICE_ROLE_KEY }}
          DASHBOARD_USERNAME: ${{ secrets.DASHBOARD_USERNAME }}
          DASHBOARD_PASSWORD: ${{ secrets.DASHBOARD_PASSWORD }}
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          cat <<EOF > .env
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=$POSTGRES_PASSWORD
          JWT_SECRET=$JWT_SECRET
          ANON_KEY=$ANON_KEY
          SERVICE_ROLE_KEY=$SERVICE_ROLE_KEY
          DASHBOARD_USERNAME=$DASHBOARD_USERNAME
          DASHBOARD_PASSWORD=$DASHBOARD_PASSWORD
          PG_META_CRYPTO_KEY=your-encryption-key-32-chars-min-meta
          POSTGRES_HOST=db
          POSTGRES_DB=postgres
          POSTGRES_PORT=5432
          KONG_HTTP_PORT=8100
          KONG_HTTPS_PORT=8143
          SERVER_IP=$SERVER_IP
          SUPABASE_PUBLIC_URL=http://$SERVER_IP:8100
          API_EXTERNAL_URL=http://$SERVER_IP:8100
          SITE_URL=http://$SERVER_IP:7001
          ADDITIONAL_REDIRECT_URLS=http://$SERVER_IP:7001,http://localhost:5173,http://localhost:3000
          JWT_EXPIRY=3600
          DISABLE_SIGNUP=false
          ENABLE_EMAIL_SIGNUP=true
          ENABLE_ANONYMOUS_USERS=false
          ENABLE_EMAIL_AUTOCONFIRM=true
          SMTP_ADMIN_EMAIL=admin@example.com
          SMTP_HOST=supabase-mail
          SMTP_PORT=2500
          SMTP_SENDER_NAME=TriathlonHelper
          MAILER_URLPATHS_CONFIRMATION="/auth/v1/verify"
          PGRST_DB_SCHEMAS=public,storage
          STUDIO_DEFAULT_ORGANIZATION=Triathlon
          STUDIO_DEFAULT_PROJECT=TriathlonHelper
          IMGPROXY_ENABLE_WEBP_DETECTION=true
          ENABLE_PHONE_SIGNUP=false
          ENABLE_PHONE_AUTOCONFIRM=false
          EOF

      - name: Prepare DB Directories and Permissions
        run: |
          # Ensure folders exist
          mkdir -p volumes/db/data
          # Secure the DB folder specifically for Postgres boot
          # We try common Postgres UIDs (999 and 70) and set strict 700 mode
          docker run --rm -v ${{ github.workspace }}:/work alpine sh -c "
            chown -R 999:999 /work/volumes/db/data || true && 
            chown -R 70:70 /work/volumes/db/data || true && 
            chmod 700 /work/volumes/db/data
          "

      - name: Start Database Only
        run: |
          docker compose up -d db

      - name: Wait for DB and Bootstrap Roles
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: |
          echo "Waiting for database to be ready via TCP..."
          # Use TCP (127.0.0.1) instead of socket to avoid permission issues during bootstrap
          # We wait up to 120 seconds
          max_attempts=60
          attempt=0
          until docker exec supabase-db pg_isready -h 127.0.0.1 -p 5432 -U postgres || [ $attempt -eq $max_attempts ]; do
            echo "Waiting... (Attempt $attempt/$max_attempts)"
            sleep 2
            attempt=$((attempt+1))
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "❌ Database failed to start."
            docker logs supabase-db --tail 50
            exit 1
          fi
          
          echo "Injecting passwords into bootstrap..."
          # Update path to match new location
          sed -i "s|DB_PASSWORD_PLACEHOLDER|$POSTGRES_PASSWORD|g" supabase/setup/bootstrap.sql
          
          echo "Applying Bootstrap (Roles & Schemas)..."
          # Run the bootstrap via the 127.0.0.1 bridge
          docker exec -i supabase-db psql -h 127.0.0.1 -U postgres -d postgres < supabase/setup/bootstrap.sql

      - name: Start Rest of Stack
        run: |
          docker compose up -d --remove-orphans

      - name: Wait for Auth Service
        run: |
          echo "Waiting for Supabase Auth to be healthy..."
          max_attempts=30
          attempt=0
          until [ "$(docker inspect --format='{{.State.Health.Status}}' supabase-auth)" == "healthy" ] || [ $attempt -eq $max_attempts ]; do
            echo "Waiting... (Attempt $attempt/$max_attempts)"
            sleep 5
            attempt=$((attempt+1))
          done

      - name: Install Supabase CLI (Binary)
        run: |
          echo "Downloading Supabase CLI..."
          # Use a confirmed .deb asset for linux_amd64
          VERSION="2.72.7"
          curl -L "https://github.com/supabase/cli/releases/download/v${VERSION}/supabase_${VERSION}_linux_amd64.deb" -o supabase.deb
          
          echo "Extracting CLI..."
          # We extract the .deb into the current folder
          dpkg -x supabase.deb .
          # Rename to avoid conflict with the 'supabase/' project directory
          mv usr/bin/supabase ./supabase-cli
          chmod +x ./supabase-cli
          ./supabase-cli --version

      - name: Apply Application Migrations (CLI)
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: |
          echo "Pushing final migrations to localhost:5433..."
          # Use --yes instead of --non-interactive (it's the correct flag for the CLI)
          ./supabase-cli db push --yes --db-url "postgresql://postgres:$POSTGRES_PASSWORD@127.0.0.1:5433/postgres"
          
          echo "Refreshing Cache..."
          docker exec supabase-db psql -h 127.0.0.1 -U postgres -d postgres -c "NOTIFY pgrst, 'reload config'"
          docker exec supabase-db psql -h 127.0.0.1 -U postgres -d postgres -c "NOTIFY pgrst, 'reload schema'"

      - name: Apply Post-Boot Setup (Storage)
        run: |
          echo "Waiting for Storage service to initialize tables..."
          sleep 10
          
          echo "Applying storage buckets and policies..."
          docker exec -i supabase-db psql -h 127.0.0.1 -U postgres -d postgres < supabase/setup/post-boot.sql
          
          echo "✅ Post-boot setup complete!"
